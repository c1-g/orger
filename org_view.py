#!/usr/bin/env python3
from argparse import ArgumentParser
import logging
from tempfile import TemporaryDirectory
from typing import NamedTuple, List, Any, Iterable, Tuple, Optional, Collection
from pathlib import Path

from kython import group_by_key
from kython.ktyping import PathIsh
from kython.klogging import setup_logzero
from kython.kos import atomic_append
from kython.state import JsonState
from kython.org_tools import as_org_entry as as_org, link as org_link

from org_utils import OrgTree, pick_heading

from atomicwrites import atomic_write
# TODO tests for determinism
# TODO unused imports? maybe even ruci?..

"""
TODO
OverWriteView -- basically what we have now
appendview -- also takes json state to track
both need new file header now...
"""

Key = str
OrgWithKey = Tuple[Key, OrgTree]

# TODO abc???
class OrgView:
    def __init__(
            self,
            logger_tag: str='org-view', # TODO loggerish?
            file_header: str="",
    ) -> None:
        self.logger = logging.getLogger(logger_tag)
        self.file_header = file_header

    def get_items(self) -> Collection[OrgWithKey]:
        raise NotImplementedError
            # TODO nicer tree generation? yieldy?

    def main_common(self) -> None:
        setup_logzero(self.logger, level=logging.DEBUG)


class OrgViewOverwrite(OrgView):
    def main(self, default_to: PathIsh) -> None:
        self.main_common()

        p = ArgumentParser()
        p.add_argument('--to', type=Path, default=Path(default_to))
        args = p.parse_args()
        self.run(args.to)


    def make_tree(self) -> OrgTree:
        items = [p[1] for p in self.get_items()] # we don't need keys here
        return  OrgTree(
            self.file_header,
            items,
        )


    def run(self, to: Path) -> None:
        # TODO make it read only??
        org_tree = self.make_tree()
        rtree = org_tree.render()
        with atomic_write(str(to), mode='w', overwrite=True) as fo:
            fo.write(rtree)


class OrgViewAppend(OrgView):
    def run(
            self,
            to: Path,
            state_path: Path,
            create: bool=False,
    ) -> None:
        state = JsonState(
            path=state_path,
            logger=self.logger,
        )
        items = self.get_items()
        assert len(set(i[0] for i in items)) == len(items), 'duplicate item keys!'
        # TODO hmm, perhaps use make_dict as well?

        if not to.exists():
            if create:
                self.logger.warning("target %s didn't exist, creating!", to)
                atomic_append(
                    to,
                    self.file_header + '\n',
                )
            else:
                raise RuntimeError("target %s doesn't exist! Try running with --create")

        for key, item in items:
            def action():
                # better to have extra whitespace than rely on trailing
                rendered = '\n' + item.render(level=1)
                atomic_append(
                    to,
                    rendered,
                )
            # TODO come up with better name?
            state.feed(
                key=key,
                value=item, # TODO not sure about this one... perhaps only link?
                action=action,
            )


    def main(self, default_to: PathIsh, default_state: PathIsh) -> None:
        self.main_common()

        p = ArgumentParser()
        p.add_argument('--to', type=Path, default=Path(default_to))
        p.add_argument('--state', type=Path, default=Path(default_state))
        p.add_argument('--create', action='store_true')
        args = p.parse_args()

        self.run(
            to=args.to,
            state_path=args.state,
            create=args.create,
        )


def test_org_view_overwrite(tmp_path: Path):
    class TestView(OrgViewOverwrite):
        def __init__(self, items: List[OrgWithKey]) -> None:
            super().__init__(file_header='# autogenerated!')
            self.items = items

        def get_items(self):
            return self.items

    rpath = tmp_path / 'test.org'

    TestView([]).run(to=rpath)
    assert rpath.read_text() == '# autogenerated!'

    TestView([
        # TODO shit, it's gonna use implicit date??
        ('first' , OrgTree(item_='whatever')),
        ('second', OrgTree(item_=lambda: 'alala')),
    ]).run(to=rpath)
    # TODO eh, perhaps use trailing space?
    assert rpath.read_text() == """
# autogenerated!
* whatever
* alala""".lstrip()


# TODO major bit of this test really belongs to json state..
# TODO try with error, make sure it's executed before action
def test_org_view_append(tmp_path: Path):
    import json
    class TestView(OrgViewAppend):
        def __init__(self, items: List[OrgWithKey]) -> None:
            super().__init__(file_header='# autogenerated!')
            self.items = items

        def get_items(self):
            return self.items

    rpath = tmp_path / 'res.org'
    spath = tmp_path / 'state.json'

    def run_view(items, **kwargs):
        TestView(items).run(
            to=rpath,
            state_path=spath,
            **kwargs,
        )

    def get_state():
        return set(json.loads(spath.read_text()).keys())

    items = []
    run_view([], create=True)
    assert rpath.read_text() == """
# autogenerated!
""".lstrip()
    # TODO do we need to touch state too??

    items.append(
        ('first', OrgTree('i am first')),
    )
    run_view(items)
    assert rpath.read_text() == """
# autogenerated!

* i am first""".lstrip()
    assert get_state() == {'first'}


    items.append(
        ('second', OrgTree('i am second')),
    )
    run_view(items)
    assert rpath.read_text() == """
# autogenerated!

* i am first
* i am second""".lstrip()
    assert get_state() == {'first', 'second'}


    rpath_time = rpath.stat().st_mtime
    spath_time = rpath.stat().st_mtime
    run_view(items)
    assert rpath.stat().st_mtime == rpath_time
    assert spath.stat().st_mtime == spath_time

