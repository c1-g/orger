#!/usr/bin/env python3
from argparse import ArgumentParser, Namespace
import logging
from tempfile import TemporaryDirectory
from typing import List, Tuple, Collection, Optional
from pathlib import Path

from kython import make_dict
from kython.ktyping import PathIsh
from kython.klogging import setup_logzero
from kython.kos import atomic_append
from kython.state import JsonState

from orger.org_utils import OrgTree

from atomicwrites import atomic_write
# TODO tests for determinism? not sure where should they be...
# think of some generic thing to test that?

Key = str
OrgWithKey = Tuple[Key, OrgTree]

class OrgView:
    """
    Override to get autogenerated header
    """
    file: str
    logger_tag: str = 'org-view'

    def __init__(
            self,
            cmdline_args: Optional[Namespace]=None,
            file_header: Optional[str]=None,
    ) -> None:
        self.cmdline_args = cmdline_args
        self.logger = logging.getLogger(self.logger_tag)
        self.file_header = file_header if file_header is not None else f"# AUTOGENERATED BY {self.file}\n"

    def get_items(self) -> Collection[OrgWithKey]:
        raise NotImplementedError

    def main_common(self) -> None:
        setup_logzero(self.logger, level=logging.DEBUG)


class OrgViewOverwrite(OrgView):
    @classmethod
    def main(cls, default_to: PathIsh, setup_parser=None) -> None:
        p = ArgumentParser()
        p.add_argument('--to', type=Path, default=Path(default_to))
        if setup_parser is not None:
            setup_parser(p)

        args = p.parse_args()
        inst = cls(cmdline_args=args)
        inst._run(to=args.to)


    def _run(self, to: Path):
        self.main_common()

        # TODO make it read only??
        org_tree = self.make_tree()
        rtree = org_tree.render()
        with atomic_write(str(to), mode='w', overwrite=True) as fo:
            fo.write(rtree)


    def make_tree(self) -> OrgTree:
        items = [p[1] for p in self.get_items()] # we don't need keys here
        return OrgTree(
            self.file_header,
            items,
        )


class OrgViewAppend(OrgView):
    def _run(
            self,
            to: Path,
            state_path: Path,
            init: bool=False,
            dry_run: bool=False,
    ) -> None:
        state = JsonState(
            path=state_path,
            logger=self.logger,
            dry_run=dry_run,
        )
        items = self.get_items()

        make_dict(items, lambda x: x[0]) # checks that no duplicate keys as a collateral

        if not to.exists():
            if init:
                self.logger.warning("target %s didn't exist, initializing!", to)
                atomic_append(
                    to,
                    self.file_header + '\n',
                )
            else:
                raise RuntimeError(f"target {to} doesn't exist! Try running with --init")

        for key, item in items:
            def action(item=item):
                # better to have extra whitespace than rely on trailing
                rendered = '\n' + item.render(level=1)
                atomic_append(
                    to,
                    rendered,
                )
            state.feed(
                key=key,
                value=item, # TODO not sure about this one... perhaps only link?
                action=action,
            )

    @classmethod
    def main(cls, default_to: PathIsh, default_state: PathIsh) -> None:
        p = ArgumentParser()
        p.add_argument('--to', type=Path, default=Path(default_to))
        p.add_argument('--state', type=Path, default=Path(default_state))
        p.add_argument('--init', action='store_true')
        p.add_argument('--dry-run', action='store_true')
        args = p.parse_args()

        inst = cls(cmdline_args=args)
        inst.main_common()
        inst._run(
            to=args.to,
            state_path=args.state,
            init=args.init,
            dry_run=args.dry_run,
        )


def test_org_view_overwrite(tmp_path: Path):
    class TestView(OrgViewOverwrite):
        def __init__(self, items: List[OrgWithKey], *args, **kwargs) -> None:
            super().__init__(*args, file_header='# autogenerated!', **kwargs) # type: ignore
            self.items = items

        def get_items(self):
            return self.items

    rpath = tmp_path / 'test.org'

    TestView([])._run(to=rpath)
    assert rpath.read_text() == '# autogenerated!'

    TestView([
        # TODO shit, it's gonna use implicit date??
        ('first' , OrgTree(item_='whatever')),
        ('second', OrgTree(item_=lambda: 'alala')),
    ])._run(to=rpath)
    # TODO eh, perhaps use trailing space?
    assert rpath.read_text() == """
# autogenerated!
* whatever
* alala""".lstrip()


# TODO major bit of this test really belongs to json state..
# TODO try with error, make sure it's executed before action
def test_org_view_append(tmp_path: Path):
    import json
    class TestView(OrgViewAppend):
        def __init__(self, items: List[OrgWithKey], *args, **kwargs) -> None:
            super().__init__(*args, file_header='# autogenerated!', **kwargs) # type: ignore
            self.items = items

        def get_items(self):
            return self.items

    rpath = tmp_path / 'res.org'
    spath = tmp_path / 'state.json'

    def run_view(items, **kwargs):
        TestView(items)._run(
            to=rpath,
            state_path=spath,
            **kwargs,
        )

    def get_state():
        return set(json.loads(spath.read_text()).keys())

    items = []
    run_view([], init=True)
    assert rpath.read_text() == """
# autogenerated!
""".lstrip()
    # TODO do we need to touch state too??

    items.append(
        ('first', OrgTree('i am first')),
    )
    run_view(items)
    assert rpath.read_text() == """
# autogenerated!

* i am first""".lstrip()
    assert get_state() == {'first'}


    items.append(
        ('second', OrgTree('i am second')),
    )
    run_view(items)
    assert rpath.read_text() == """
# autogenerated!

* i am first
* i am second""".lstrip()
    assert get_state() == {'first', 'second'}


    rpath_time = rpath.stat().st_mtime
    spath_time = rpath.stat().st_mtime
    run_view(items)
    assert rpath.stat().st_mtime == rpath_time
    assert spath.stat().st_mtime == spath_time

